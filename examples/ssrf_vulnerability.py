"""
SSRF Vulnerability Example - CWE-918, OWASP A10:2025 (Server-Side Request Forgery)

This code demonstrates a CRITICAL SSRF vulnerability where
user-controlled URLs can be used to access internal resources.

Expected Findings:
- CRITICAL: SSRF via user-controlled URL (confidence: 1.0)
- HIGH: No URL validation or allowlist (confidence: 0.95)
- MEDIUM: Internal service exposure risk (confidence: 0.85)

Expected Verdict: ðŸš« BLOCK

Attack Vector:
    url = "http://169.254.169.254/latest/meta-data/iam/security-credentials/"
    # Accesses AWS metadata endpoint from inside the network

    url = "http://localhost:6379/CONFIG GET *"
    # Accesses internal Redis server

    url = "file:///etc/passwd"
    # Reads local files via file:// protocol

Remediation:
    1. Validate URLs against an allowlist of permitted domains
    2. Block internal/private IP ranges (10.x, 172.16-31.x, 192.168.x, 127.x)
    3. Disable unnecessary URL schemes (file://, gopher://, dict://)
    4. Use a proxy with strict egress controls
    5. Validate and sanitize redirects
"""

import urllib.request

import requests


def fetch_url_vulnerable(user_url: str) -> str:
    """
    VULNERABLE: Directly fetches user-provided URL without validation.

    This allows attackers to:
    - Access internal services (localhost, internal IPs)
    - Access cloud metadata endpoints
    - Scan internal network
    - Read local files
    """
    response = requests.get(user_url)  # SSRF vulnerability
    return response.text


def fetch_image_vulnerable(image_url: str) -> bytes:
    """
    VULNERABLE: Fetches image from user URL.

    Even if expecting an image, the URL can point to
    internal resources that return any content.
    """
    with urllib.request.urlopen(image_url) as response:  # SSRF vulnerability
        return response.read()


def webhook_vulnerable(webhook_url: str, data: dict) -> bool:
    """
    VULNERABLE: Sends data to user-specified webhook.

    Attackers can use this to:
    - Probe internal network
    - Send data to malicious endpoints
    - Trigger actions on internal services
    """
    try:
        response = requests.post(webhook_url, json=data)  # SSRF vulnerability
        return response.status_code == 200
    except Exception:
        return False


# Example of SECURE implementation
def fetch_url_secure(user_url: str, allowed_domains: list[str]) -> str:
    """
    SECURE: Validates URL against allowlist before fetching.
    """
    from urllib.parse import urlparse

    parsed = urlparse(user_url)

    # Validate scheme
    if parsed.scheme not in ("http", "https"):
        raise ValueError(f"Invalid URL scheme: {parsed.scheme}")

    # Validate domain against allowlist
    if parsed.netloc not in allowed_domains:
        raise ValueError(f"Domain not allowed: {parsed.netloc}")

    # Block private IP ranges (simplified check)
    import socket

    try:
        ip = socket.gethostbyname(parsed.hostname)
        if ip.startswith(("10.", "172.", "192.168.", "127.")):
            raise ValueError("Internal IP addresses not allowed")
    except socket.gaierror:
        raise ValueError("Could not resolve hostname")

    response = requests.get(user_url)
    return response.text


if __name__ == "__main__":
    # Attack examples
    malicious_urls = [
        "http://169.254.169.254/latest/meta-data/",  # AWS metadata
        "http://localhost:6379/",  # Internal Redis
        "http://127.0.0.1:5000/admin",  # Internal admin
        "file:///etc/passwd",  # Local file read
    ]

    for url in malicious_urls:
        print(f"Attempting SSRF to: {url}")
        # fetch_url_vulnerable(url)  # Would succeed if run
